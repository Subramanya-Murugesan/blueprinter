module Blueprinter
  module AssociationHelpers
    SINGULAR_ASSOCIATION_MACROS = [:belongs_to, :has_one].freeze
    COLLECTION_ASSOCIATION_MACROS = [:habtm, :has_many].freeze

    # {:successor_ids => :successors, :successors => :successors}
    def get_field_to_association_hash(object_relation)
      full_hash = Hash.new
      associations = object_relation.reflect_on_all_associations
      associations.each do |association|
        if SINGULAR_ASSOCIATION_MACROS.include?(association.macro)
          full_hash.merge!(singular_associated_fields_hash(object_relation, association.name))
        elsif COLLECTION_ASSOCIATION_MACROS.include?(association.macro)
          full_hash.merge!(collection_associated_fields_hash(object_relation, association.name))
        end
      end

      full_hash
    end

    private

    # belongs_to, belongs_to :polymorphic, has_one
    def singular_associated_fields_hash(object_relation, association_name_as_symbol)
      singular_association_hash = Hash.new
      # field => association_name
      if object_relation[0].respond_to?(association_name_as_symbol)
        singular_association_hash[association_name_as_symbol] = association_name_as_symbol
      end
      singular_association_hash
    end

    def collection_associated_fields_hash(object_relation, association_name_as_symbol)
      collection_associated_hash = Hash.new
      if object_relation[0].respond_to?(association_name_as_symbol)
        collection_associated_hash[association_name_as_symbol] = association_name_as_symbol
      end
      # do our best to determine the autogenerated method name. Does not account for custom names
      collection_ids = association_name_as_symbol.to_s[0..-2] + '_ids'

      if object_relation[0].respond_to?(collection_ids&.to_sym)
        collection_associated_hash[collection_ids&.to_sym] = association_name_as_symbol
      end
      collection_associated_hash
    end
  end
end